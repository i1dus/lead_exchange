// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: lead.proto

package leadexchangev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _lead_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on Lead with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Lead) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Lead with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LeadMultiError, or nil if none found.
func (m *Lead) ValidateAll() error {
	return m.validate(true)
}

func (m *Lead) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeadId

	if utf8.RuneCountInString(m.GetTitle()) < 3 {
		err := LeadValidationError{
			field:  "Title",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	// no validation rules for Requirement

	if utf8.RuneCountInString(m.GetContactName()) < 2 {
		err := LeadValidationError{
			field:  "ContactName",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Lead_ContactPhone_Pattern.MatchString(m.GetContactPhone()) {
		err := LeadValidationError{
			field:  "ContactPhone",
			reason: "value does not match regex pattern \"^\\\\+?[0-9\\\\s()-]{7,}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetContactEmail() != "" {

		if err := m._validateEmail(m.GetContactEmail()); err != nil {
			err = LeadValidationError{
				field:  "ContactEmail",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Status

	if err := m._validateUuid(m.GetOwnerUserId()); err != nil {
		err = LeadValidationError{
			field:  "OwnerUserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetCreatedUserId()); err != nil {
		err = LeadValidationError{
			field:  "CreatedUserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return LeadMultiError(errors)
	}

	return nil
}

func (m *Lead) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *Lead) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

func (m *Lead) _validateUuid(uuid string) error {
	if matched := _lead_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// LeadMultiError is an error wrapping multiple validation errors returned by
// Lead.ValidateAll() if the designated constraints aren't met.
type LeadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeadMultiError) AllErrors() []error { return m }

// LeadValidationError is the validation error returned by Lead.Validate if the
// designated constraints aren't met.
type LeadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeadValidationError) ErrorName() string { return "LeadValidationError" }

// Error satisfies the builtin error interface
func (e LeadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLead.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeadValidationError{}

var _Lead_ContactPhone_Pattern = regexp.MustCompile("^\\+?[0-9\\s()-]{7,}$")

// Validate checks the field values on CreateLeadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLeadRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateLeadRequestMultiError, or nil if none found.
func (m *CreateLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTitle()) < 3 {
		err := CreateLeadRequestValidationError{
			field:  "Title",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	// no validation rules for Requirement

	if utf8.RuneCountInString(m.GetContactName()) < 2 {
		err := CreateLeadRequestValidationError{
			field:  "ContactName",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateLeadRequest_ContactPhone_Pattern.MatchString(m.GetContactPhone()) {
		err := CreateLeadRequestValidationError{
			field:  "ContactPhone",
			reason: "value does not match regex pattern \"^\\\\+?[0-9\\\\s()-]{7,}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetContactEmail() != "" {

		if err := m._validateEmail(m.GetContactEmail()); err != nil {
			err = CreateLeadRequestValidationError{
				field:  "ContactEmail",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateLeadRequestMultiError(errors)
	}

	return nil
}

func (m *CreateLeadRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *CreateLeadRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CreateLeadRequestMultiError is an error wrapping multiple validation errors
// returned by CreateLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLeadRequestMultiError) AllErrors() []error { return m }

// CreateLeadRequestValidationError is the validation error returned by
// CreateLeadRequest.Validate if the designated constraints aren't met.
type CreateLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLeadRequestValidationError) ErrorName() string {
	return "CreateLeadRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLeadRequestValidationError{}

var _CreateLeadRequest_ContactPhone_Pattern = regexp.MustCompile("^\\+?[0-9\\s()-]{7,}$")

// Validate checks the field values on GetLeadRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLeadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetLeadRequestMultiError,
// or nil if none found.
func (m *GetLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetLeadId()); err != nil {
		err = GetLeadRequestValidationError{
			field:  "LeadId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetLeadRequestMultiError(errors)
	}

	return nil
}

func (m *GetLeadRequest) _validateUuid(uuid string) error {
	if matched := _lead_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetLeadRequestMultiError is an error wrapping multiple validation errors
// returned by GetLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type GetLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLeadRequestMultiError) AllErrors() []error { return m }

// GetLeadRequestValidationError is the validation error returned by
// GetLeadRequest.Validate if the designated constraints aren't met.
type GetLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLeadRequestValidationError) ErrorName() string { return "GetLeadRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLeadRequestValidationError{}

// Validate checks the field values on ListLeadsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListLeadsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeadsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeadsRequestMultiError, or nil if none found.
func (m *ListLeadsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeadsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListLeadsRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListLeadsRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListLeadsRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListLeadsRequestMultiError(errors)
	}

	return nil
}

// ListLeadsRequestMultiError is an error wrapping multiple validation errors
// returned by ListLeadsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListLeadsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeadsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeadsRequestMultiError) AllErrors() []error { return m }

// ListLeadsRequestValidationError is the validation error returned by
// ListLeadsRequest.Validate if the designated constraints aren't met.
type ListLeadsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeadsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeadsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeadsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeadsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeadsRequestValidationError) ErrorName() string { return "ListLeadsRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListLeadsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeadsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeadsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeadsRequestValidationError{}

// Validate checks the field values on ListLeadsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListLeadsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeadsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeadsResponseMultiError, or nil if none found.
func (m *ListLeadsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeadsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLeads() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListLeadsResponseValidationError{
						field:  fmt.Sprintf("Leads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListLeadsResponseValidationError{
						field:  fmt.Sprintf("Leads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListLeadsResponseValidationError{
					field:  fmt.Sprintf("Leads[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListLeadsResponseMultiError(errors)
	}

	return nil
}

// ListLeadsResponseMultiError is an error wrapping multiple validation errors
// returned by ListLeadsResponse.ValidateAll() if the designated constraints
// aren't met.
type ListLeadsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeadsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeadsResponseMultiError) AllErrors() []error { return m }

// ListLeadsResponseValidationError is the validation error returned by
// ListLeadsResponse.Validate if the designated constraints aren't met.
type ListLeadsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeadsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeadsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeadsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeadsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeadsResponseValidationError) ErrorName() string {
	return "ListLeadsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListLeadsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeadsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeadsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeadsResponseValidationError{}

// Validate checks the field values on UpdateLeadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateLeadRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateLeadRequestMultiError, or nil if none found.
func (m *UpdateLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetLeadId()); err != nil {
		err = UpdateLeadRequestValidationError{
			field:  "LeadId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Title != nil {
		// no validation rules for Title
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Requirement != nil {
		// no validation rules for Requirement
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.OwnerUserId != nil {
		// no validation rules for OwnerUserId
	}

	if len(errors) > 0 {
		return UpdateLeadRequestMultiError(errors)
	}

	return nil
}

func (m *UpdateLeadRequest) _validateUuid(uuid string) error {
	if matched := _lead_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// UpdateLeadRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLeadRequestMultiError) AllErrors() []error { return m }

// UpdateLeadRequestValidationError is the validation error returned by
// UpdateLeadRequest.Validate if the designated constraints aren't met.
type UpdateLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLeadRequestValidationError) ErrorName() string {
	return "UpdateLeadRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLeadRequestValidationError{}

// Validate checks the field values on LeadResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LeadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeadResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LeadResponseMultiError, or
// nil if none found.
func (m *LeadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LeadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeadResponseValidationError{
				field:  "Lead",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LeadResponseMultiError(errors)
	}

	return nil
}

// LeadResponseMultiError is an error wrapping multiple validation errors
// returned by LeadResponse.ValidateAll() if the designated constraints aren't met.
type LeadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeadResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeadResponseMultiError) AllErrors() []error { return m }

// LeadResponseValidationError is the validation error returned by
// LeadResponse.Validate if the designated constraints aren't met.
type LeadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeadResponseValidationError) ErrorName() string { return "LeadResponseValidationError" }

// Error satisfies the builtin error interface
func (e LeadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeadResponseValidationError{}

// Validate checks the field values on ListLeadsRequest_Filter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListLeadsRequest_Filter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeadsRequest_Filter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeadsRequest_FilterMultiError, or nil if none found.
func (m *ListLeadsRequest_Filter) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeadsRequest_Filter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.OwnerUserId != nil {
		// no validation rules for OwnerUserId
	}

	if m.CreatedUserId != nil {
		// no validation rules for CreatedUserId
	}

	if len(errors) > 0 {
		return ListLeadsRequest_FilterMultiError(errors)
	}

	return nil
}

// ListLeadsRequest_FilterMultiError is an error wrapping multiple validation
// errors returned by ListLeadsRequest_Filter.ValidateAll() if the designated
// constraints aren't met.
type ListLeadsRequest_FilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeadsRequest_FilterMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeadsRequest_FilterMultiError) AllErrors() []error { return m }

// ListLeadsRequest_FilterValidationError is the validation error returned by
// ListLeadsRequest_Filter.Validate if the designated constraints aren't met.
type ListLeadsRequest_FilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeadsRequest_FilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeadsRequest_FilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeadsRequest_FilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeadsRequest_FilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeadsRequest_FilterValidationError) ErrorName() string {
	return "ListLeadsRequest_FilterValidationError"
}

// Error satisfies the builtin error interface
func (e ListLeadsRequest_FilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeadsRequest_Filter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeadsRequest_FilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeadsRequest_FilterValidationError{}
